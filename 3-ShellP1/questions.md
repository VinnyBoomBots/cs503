1. In this assignment I suggested you use `fgets()` to get user input in the main while loop. Why is `fgets()` a good choice for this application?

    > **Answer**: Now that I've read the man file on it, fgets() seems like the ideal function for this program. It processes all command-line inputs and stores them in a buffer as a continuous string -- and if no inputs are provided, the function returns a NULL value, which the program can then easily then accomodate with a warning message. 

2. You needed to use `malloc()` to allocte memory for `cmd_buff` in `dsh_cli.c`. Can you explain why you needed to do that, instead of allocating a fixed-size array?

    > **Answer**: Dynamically allocating memory via the malloc() function seems like a far more prudent option than allocating memory via a fixed-size array, especially considering that we are filling the buffer with user input and there is no way of knowing ahead of time what that input will be. It is thus wiser to dynamically allocate memory and adapt to a given input, rather than attempt to predict in advance what the likely size of user input will be. 


3. In `dshlib.c`, the function `build_cmd_list()` must trim leading and trailing spaces from each command before storing it. Why is this necessary? If we didn't trim spaces, what kind of issues might arise when executing commands in our shell?

    > **Answer**: Since spaces in Linux are not just blank spaces but characters themselves -- and specifically they act as the separators between commands -- it is important that additional, unintentional, or simply incorrect spaces are not transposed from the command line into the array those commands are stored in. I would not be surprised if the incorrect storage of such spaces leads to errors in executing those commands later on. Also, it should never be underestimated the importance of human readability and neatness in outputs as source code grows in complexity over time.  

4. For this question you need to do some research on STDIN, STDOUT, and STDERR in Linux. We've learned this week that shells are "robust brokers of input and output". Google _"linux shell stdin stdout stderr explained"_ to get started.

- One topic you should have found information on is "redirection". Please provide at least 3 redirection examples that we should implement in our custom shell, and explain what challenges we might have implementing them.

    > **Answer**: After reading a bit about I/O streams and redirection, it seems to me that in our Drexel shell we'd certainly want implement the capability to redirect stdin FROM a file, redirect stdout TO a file, and APPEND stdout to a file via redirection. And in light of the material covered in lecture this week, I assume (and some of the reading I did confirmed this) that redirection-implementation issues could arise when using the fork() and posix_spawn() functions -- because when we use these functions, we, as coders, have to ensure that the child processes and the parent processes execute together and not on disparate paths (this phenomenon was referred to as "process control" in one of the pages I read). I would also assume that if multiple redirections are in play, this complicates implementation and that the shell itself has to possess certain logic in order to handle these multiple streams and their distinct redirections. 

- You should have also learned about "pipes". Redirection and piping both involve controlling input and output in the shell, but they serve different purposes. Explain the key differences between redirection and piping.

    > **Answer**: I would say the big difference I picked up on between redirection and piping is that redirection changes WHAT stream is the input or WHERE that specific stream is directed -- while piping is a method used to "chain" mulitple commands together, with the output of the first command then becoming the input of the second, and on and on down the line. This chaining of commands allows for the further processing of inputs and outputs without having to skip between intermediary states. The logic can certainly become complicated, but it is obviously a very powerful computational option -- and, moreover, it does not "involve file operations" unless explixitly stated (which I quote directly, as I stole this wording directly from a Web page I used as a source).

- STDERR is often used for error messages, while STDOUT is for regular output. Why is it important to keep these separate in a shell?

    > **Answer**: You would want to keep standard output and standard errors separate from each other if only because they represent completely different things: output is what a program or operation produces (whether unwittingly or not), and errors are the things that went wrong during the execution of that operation. You want operations to produce both, no doubt, but you want to see them as separate from one another for clarity's sake -- and for the advantages that their separation lends to debugging and editing efforts later on. Also (and I learned this from a Web page I perused), by having the two streams separate, it allows the user to manipulate them both independently through redirection, which allows for even greater separation of outputs and errors -- which, again, improves debugging efforts by isolating the two from one another.  

- How should our custom shell handle errors from commands that fail? Consider cases where a command outputs both STDOUT and STDERR. Should we provide a way to merge them, and if so, how?

    > **Answer**: My initial thought, if only to echo my response to the previous question, is that STDOUT and STDERR should, by default, be separated (for all the benefits enumerated above). However, providing a mechanism to merge them should be available (if only to cover all possible user preferences), and from the Internet reading I did it does appear as if most shells accomodate this merging. As far as what the source code would look like to accomplish this, I would assume that utilizing the fork() or posix_spawn() functions would be helpful, in order to run multiple processes at the same time -- and, according to a Web page I perused, it seems as if the dup2() function would also be helpful, as it "duplicates a file descriptor to another file descriptor," which, so this page stated, can be used to merge STDOUT with STDERR.